title "softcpu";

include "lpm_counter.inc";
include "rom16.inc";
include "ram8.inc";

-- commands
constant NOP          = 0; -- no operation
constant READ         = 1; -- read from RAM to ACCUM
constant WRITE        = 2; -- write from ACCUM to RAM
constant READ_ADDR    = 3; -- read from address from ADDR
constant WRITE_ADDR   = 4; -- write to address from ADDR

constant SET          = 8; -- set constant value
constant PUT_ADDR     = 9; -- copy value from ACCUM to ADDR

constant JUMP         = 16; -- jump to instruction
constant JUMP_IF      = 17; -- jump to instruction if ACCUM is non-zero
constant JUMP_ADDR    = 18; -- jump to instruction from ADDR
constant JUMP_ADDR_IF = 19; -- jump to instruction from ADDR if ACCUM is non-zero

constant RESET        = 255; -- jump to zero instruction

subdesign softcpu
(
	clock: input;
	_accum[7..0]: output;
	_addr[7..0]: output;
	
	_wr_acc: output;
	_wr_ram: output;
	_wr_addr: output;
	
	_accum_clk: output;
	_addr_clk: output;
	_ram_wren: output;
	
	_stage[2..0]: output;
	_ip[7..0]: output;
	
	_rom[15..0]: output;
	_ram[7..0]: output;
)

variable
	accum[7..0]: DFF; -- accumulator register
	addr[7..0]: DFF; -- address register
	
	wr_acc: node;
	wr_ram: node;
	wr_addr: node;
	
	accum_clk: node;
	addr_clk: node;
	ram_wren: node;
	
	stage: LPM_Counter with (lpm_width=3, lpm_modulus=8); -- stage counter
	ip: LPM_Counter with (lpm_width=8); -- instruction pointer register
	
	rom: ROM16;
	ram: RAM8;
	
	cmd[7..0]: node;
	arg[7..0]: node;
begin
	stage.clock = clock;
	ip.clock = clock;
	ip.clk_en = (stage.q[] == 7);

	rom.address[] = ip.q[];
	rom.clock = clock;
	
	ram.clock = clock;
	
	cmd[] = rom.q[15..8];
	arg[] = rom.q[7..0];
	
	accum_clk = clock and wr_acc and stage.q[] == 3;
	addr_clk = clock and wr_addr and stage.q[] == 3;
	accum[].clk = accum_clk;
	addr[].clk = addr_clk;
	
	ram_wren = wr_ram and stage.q[] == 3;
	ram.wren = ram_wren;
	
	-- READ, READ_ADDR command
	if cmd[] == READ or cmd[] == READ_ADDR then
		if cmd[] == READ then
			ram.address[] = arg[];
		else
			ram.address[] = addr[].q;
		end if;
		accum[].d = ram.q[];
		wr_acc = VCC;
	else
		wr_acc = GND;
	end if;
	
	-- WRITE, WRITE_ADDR command
	if cmd[] == WRITE or cmd[] == WRITE_ADDR then
		if cmd[] == WRITE then
			ram.address[] = arg[];
		else
			ram.address[] = addr[].q;
		end if;
		ram.data[] = accum[].q;
		wr_ram = VCC;
	else
		wr_ram = GND;
	end if;
	
	-- SET command
	if cmd[] == SET then
		accum[].d = arg[];
		wr_acc = VCC;
	else
		wr_acc = GND;
	end if;
	
	-- PUT_ADDR command
	if cmd[] == PUT_ADDR then
		addr[].d = accum[].q;
		wr_addr = VCC;
	else
		wr_addr = GND;
	end if;
	
	-- JUMP, JUMP_IF, JUMP_ADDR, JUMP_ADDR_IF commands
	if cmd[] == JUMP or cmd[] == JUMP_ADDR or 
	  ((cmd[] == JUMP_IF or cmd[] == JUMP_ADDR_IF) and accum[].q != 0) then
		if cmd[] == JUMP or cmd[] == JUMP_IF then
			ip.data[] = arg[];
		else
			ip.data[] = addr[].q;
		end if;
		ip.sload = VCC;
	else
		ip.sload = GND;
	end if;
	
	-- RESET command
	if cmd[] == RESET then
		ip.sclr = VCC;
	else
		ip.sclr = GND;
	end if;

	_accum[] = accum[].q;
	_addr[] = addr[].q;
	
	_stage[] = stage.q[];
	_ip[] = ip.q[];
	
	_rom[] = rom.q[];
	_ram[] = ram.q[];
	
	_wr_acc = wr_acc;
	_wr_ram = wr_ram;
	_wr_addr = wr_addr;
	
	_accum_clk = accum_clk;
	_addr_clk = addr_clk;
	_ram_wren = ram_wren;
end;
